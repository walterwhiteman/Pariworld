import { users, roomParticipants, messages, type User, type InsertUser, type RoomParticipant } from "@shared/schema";
import { db } from "./db";
import { eq, and, desc } from "drizzle-orm"; // Import 'desc' for ordering by timestamp

// Define ChatMessage interface for server use.
// This interface should match the structure of a message as it exists in your database.
interface ChatMessage {
  id: string; // Assuming 'id' is generated by the DB and we want it as a string
  roomId: string;
  sender: string;
  content: string | null; // Content can be null if it's an image message
  imageData: string | null; // ImageData can be null if it's a text message
  messageType: 'text' | 'image' | 'system';
  timestamp: Date; // Assuming 'timestamp' is generated by the DB and stored as a Date object
}

export interface IStorage {
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  addRoomParticipant(roomId: string, username: string): Promise<void>;
  removeRoomParticipant(roomId: string, username: string): Promise<void>;
  getRoomParticipants(roomId: string): Promise<RoomParticipant[]>;
  // Updated addMessage to return the ChatMessage
  addMessage(message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<ChatMessage>;
  // Added getMessages method
  getMessages(roomId: string, limit?: number): Promise<ChatMessage[]>;
  // You might also want deleteOldMessages from your routes.ts cleanup interval
  deleteOldMessages(cutoff: Date): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async addRoomParticipant(roomId: string, username: string): Promise<void> {
    // Check if participant already exists
    const [existing] = await db
      .select()
      .from(roomParticipants)
      .where(and(
        eq(roomParticipants.roomId, roomId),
        eq(roomParticipants.username, username)
      ));

    if (!existing) {
      // Add new participant
      await db.insert(roomParticipants).values({
        roomId,
        username,
        isActive: true
      });
    } else {
      // Update existing participant to active
      await db
        .update(roomParticipants)
        .set({ isActive: true })
        .where(and(
          eq(roomParticipants.roomId, roomId),
          eq(roomParticipants.username, username)
        ));
    }
  }

  async removeRoomParticipant(roomId: string, username: string): Promise<void> {
    await db
      .update(roomParticipants)
      .set({ isActive: false })
      .where(and(
        eq(roomParticipants.roomId, roomId),
        eq(roomParticipants.username, username)
      ));
  }

  async getRoomParticipants(roomId: string): Promise<RoomParticipant[]> {
    return await db
      .select()
      .from(roomParticipants)
      .where(and(
        eq(roomParticipants.roomId, roomId),
        eq(roomParticipants.isActive, true)
      ));
  }

  async addMessage(message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<ChatMessage> {
    // Insert the message and use .returning() to get the full inserted row
    const [insertedMessage] = await db.insert(messages).values({
      roomId: message.roomId,
      sender: message.sender,
      content: message.content,
      imageData: message.imageData,
      messageType: message.messageType,
      // Do NOT include `id` or `timestamp` here if your DB generates them automatically.
      // Drizzle's .returning() will automatically pick them up.
    }).returning(); // <-- Crucial: This makes the query return the inserted row

    if (!insertedMessage) {
        throw new Error("Failed to insert message into database.");
    }

    // Map the returned Drizzle object to your ChatMessage interface, ensuring types
    return {
        id: String(insertedMessage.id), // Convert to string as per ChatMessage interface
        roomId: insertedMessage.roomId,
        sender: insertedMessage.sender,
        content: insertedMessage.content,
        imageData: insertedMessage.imageData,
        messageType: insertedMessage.messageType as 'text' | 'image' | 'system', // Type assertion
        timestamp: new Date(insertedMessage.timestamp), // Convert to Date object
    };
  }

  async getMessages(roomId: string, limit: number = 50): Promise<ChatMessage[]> {
    const fetchedMessages = await db.select()
      .from(messages)
      .where(eq(messages.roomId, roomId))
      .orderBy(desc(messages.timestamp)) // Order by timestamp descending to get latest first
      .limit(limit);

    // Map fetched messages to ChatMessage interface
    const mappedMessages = fetchedMessages.map(msg => ({
      id: String(msg.id), // Ensure ID is string
      roomId: msg.roomId,
      sender: msg.sender,
      content: msg.content || null, // Ensure null if undefined/null from DB
      imageData: msg.imageData || null, // Ensure null if undefined/null from DB
      messageType: msg.messageType as 'text' | 'image' | 'system', // Type assertion
      timestamp: new Date(msg.timestamp), // Convert to Date object
    }));

    // Return messages in chronological order (oldest first) for chat display
    return mappedMessages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
  }

  async deleteOldMessages(cutoff: Date): Promise<void> {
    await db.delete(messages).where(desc(messages.timestamp).lt(cutoff));
  }
}

export const storage = new DatabaseStorage();
