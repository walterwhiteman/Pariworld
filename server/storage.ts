import { users, roomParticipants, messages, type User, type InsertUser, type RoomParticipant } from "@shared/schema";
import { db } from "./db";
import { eq, and, desc, sql, lt } from "drizzle-orm"; // Import desc, sql, and lt for queries

// Define ChatMessage interface for server use
// Note: 'id' will be auto-generated by serial(), but we still include it for consistency
// when fetching/sending messages.
interface ChatMessage {
    id: number; // Changed to number to match serial('id')
    roomId: string;
    sender: string;
    content?: string;
    imageData?: string;
    messageType: 'text' | 'image' | 'system';
    timestamp: Date;
}

export interface IStorage {
    getUser(id: number): Promise<User | undefined>;
    getUserByUsername(username: string): Promise<User | undefined>;
    createUser(user: InsertUser): Promise<User>;
    addRoomParticipant(roomId: string, username: string): Promise<void>;
    removeRoomParticipant(roomId: string, username: string): Promise<void>;
    getRoomParticipants(roomId: string): Promise<RoomParticipant[]>;
    addMessage(message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<void>; // Omit id and timestamp as DB handles them
    getMessages(roomId: string, limit?: number): Promise<ChatMessage[]>;
    deleteOldMessages(cutoffTime: Date): Promise<void>;
}

export class DatabaseStorage implements IStorage {
    async getUser(id: number): Promise<User | undefined> {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || undefined;
    }

    async getUserByUsername(username: string): Promise<User | undefined> {
        const [user] = await db.select().from(users).where(eq(users.username, username));
        return user || undefined;
    }

    async createUser(insertUser: InsertUser): Promise<User> {
        const [user] = await db
            .insert(users)
            .values(insertUser)
            .returning();
        return user;
    }

    async addRoomParticipant(roomId: string, username: string): Promise<void> {
        const [existing] = await db
            .select()
            .from(roomParticipants)
            .where(and(
                eq(roomParticipants.roomId, roomId),
                eq(roomParticipants.username, username)
            ));

        if (!existing) {
            await db.insert(roomParticipants).values({
                roomId,
                username,
                isActive: true
            });
        } else {
            await db
                .update(roomParticipants)
                .set({ isActive: true })
                .where(and(
                    eq(roomParticipants.roomId, roomId),
                    eq(roomParticipants.username, username)
                ));
        }
    }

    async removeRoomParticipant(roomId: string, username: string): Promise<void> {
        await db
            .update(roomParticipants)
            .set({ isActive: false })
            .where(and(
                eq(roomParticipants.roomId, roomId),
                eq(roomParticipants.username, username)
            ));
    }

    async getRoomParticipants(roomId: string): Promise<RoomParticipant[]> {
        return await db
            .select()
            .from(roomParticipants)
            .where(and(
                eq(roomParticipants.roomId, roomId),
                eq(roomParticipants.isActive, true)
            ));
    }

    // MODIFIED: 'id' and 'timestamp' are handled by the database schema (serial and defaultNow)
    async addMessage(message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<void> {
        await db.insert(messages).values({
            roomId: message.roomId,
            sender: message.sender,
            content: message.content,
            imageData: message.imageData,
            messageType: message.messageType,
            // id and timestamp are automatically generated by the database due to your schema.ts
        });
    }

    /**
     * Retrieves messages for a given room, ordered by timestamp.
     * @param roomId The ID of the room.
     * @param limit The maximum number of messages to retrieve (default: 50).
     * @returns An array of ChatMessage objects, ordered from oldest to newest.
     */
    async getMessages(roomId: string, limit: number = 50): Promise<ChatMessage[]> {
        const fetchedMessages = await db
            .select()
            .from(messages)
            .where(eq(messages.roomId, roomId))
            .orderBy(desc(messages.timestamp)) // Fetch most recent messages first
            .limit(limit);

        // Map Drizzle's generic result to ChatMessage interface
        // Reverse to get chronological order (oldest to newest)
        return fetchedMessages.reverse().map(msg => ({
            id: msg.id,
            roomId: msg.roomId,
            sender: msg.sender,
            content: msg.content || undefined,
            imageData: msg.imageData || undefined,
            messageType: msg.messageType,
            timestamp: new Date(msg.timestamp) // Ensure it's a Date object
        }));
    }

    /**
     * Deletes messages from the database that are older than a specified cutoff time.
     * @param cutoffTime Messages with a 'timestamp' older than this Date will be deleted.
     */
    async deleteOldMessages(cutoffTime: Date): Promise<void> {
        const result = await db.delete(messages)
            .where(lt(messages.timestamp, cutoffTime))
            .returning({ id: messages.id }); // Return IDs of deleted messages for logging/confirmation

        console.log(`Deleted ${result.length} messages older than ${cutoffTime.toISOString()}`);
    }
}

export const storage = new DatabaseStorage();
