// src/storage.ts (Complete Code - MODIFIED with types)

import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres'; // Correct import for node-postgres
import * as schema from '../shared/schema'; // Import your Drizzle schema

const connectionString = process.env.DATABASE_URL;

if (!connectionString) {
    throw new Error('DATABASE_URL environment variable is not set.');
}

const pool = new Pool({
    connectionString: connectionString,
    ssl: {
        rejectUnauthorized: false
    }
});

const db = drizzle(pool, { schema });

// Define ChatMessage interface for consistency
interface ChatMessage {
    id?: number; // Optional as it's auto-generated by DB
    roomId: string;
    sender: string;
    content?: string;
    imageData?: string;
    messageType: 'text' | 'image' | 'system';
    timestamp: Date;
}

interface RoomParticipant {
    id?: number;
    roomId: string;
    username: string;
    joinedAt: Date;
    lastSeen: Date;
}

/**
 * Adds a new message to the database.
 */
export async function addMessage(message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<void> {
    try {
        await db.insert(schema.messages).values({
            roomId: message.roomId,
            sender: message.sender,
            content: message.content,
            imageData: message.imageData,
            messageType: message.messageType,
            timestamp: new Date() // Ensure timestamp is a Date object when saving
        });
        console.log(`[Storage] Message added to room ${message.roomId} by ${message.sender}`);
    } catch (error) {
        console.error('[Storage] Error adding message:', error);
        throw error;
    }
}

/**
 * Retrieves messages for a given room, ordered by timestamp.
 */
export async function getMessages(roomId: string, limit: number = 50): Promise<ChatMessage[]> {
    try {
        const result = await db.query.messages.findMany({
            where: (messages, { eq }) => eq(messages.roomId, roomId),
            orderBy: (messages, { asc }) => asc(messages.timestamp),
            limit: limit
        });
        console.log(`[Storage] Retrieved ${result.length} messages for room ${roomId}`);
        return result.map(msg => ({ // Explicitly type msg
            id: msg.id,
            roomId: msg.roomId,
            sender: msg.sender,
            content: msg.content || undefined,
            imageData: msg.imageData || undefined,
            messageType: msg.messageType as 'text' | 'image' | 'system',
            timestamp: msg.timestamp
        }));
    } catch (error) {
        console.error('[Storage] Error getting messages:', error);
        throw error;
    }
}

/**
 * Adds or updates a room participant's last seen time.
 */
export async function addRoomParticipant(roomId: string, username: string): Promise<void> {
    try {
        // Check if participant already exists and is active
        const existing = await db.query.roomParticipants.findFirst({
            where: (participants, { eq, and }) => and(
                eq(participants.roomId, roomId),
                eq(participants.username, username)
            )
        });

        if (existing) {
            // Update lastSeen for existing participant
            await db.update(schema.roomParticipants)
                .set({ lastSeen: new Date() })
                .where(
                    and(
                        eq(schema.roomParticipants.roomId, roomId),
                        eq(schema.roomParticipants.username, username)
                    )
                );
            console.log(`[Storage] Updated lastSeen for participant ${username} in room ${roomId}`);
        } else {
            // Add new participant
            await db.insert(schema.roomParticipants).values({
                roomId,
                username,
                joinedAt: new Date(),
                lastSeen: new Date()
            });
            console.log(`[Storage] Added new participant ${username} to room ${roomId}`);
        }
    } catch (error) {
        console.error('[Storage] Error adding/updating room participant:', error);
        throw error;
    }
}

/**
 * Marks a participant as inactive (or removes them) from a room.
 */
export async function removeRoomParticipant(roomId: string, username: string): Promise<void> {
    try {
        // For simplicity, we'll delete the participant. In a real app, you might mark them inactive.
        await db.delete(schema.roomParticipants)
            .where(
                and(
                    eq(schema.roomParticipants.roomId, roomId),
                    eq(schema.roomParticipants.username, username)
                )
            );
        console.log(`[Storage] Removed participant ${username} from room ${roomId}`);
    } catch (error) {
        console.error('[Storage] Error removing room participant:', error);
        throw error;
    }
}

/**
 * Deletes messages older than a specified date.
 */
export async function deleteOldMessages(beforeDate: Date): Promise<number> {
    try {
        const result = await db.delete(schema.messages)
            .where(
                schema.messages.timestamp.lt(beforeDate)
            )
            .returning({ id: schema.messages.id }); // Return deleted IDs to get row count
        console.log(`[Storage] Deleted ${result.length} messages older than ${beforeDate.toISOString()}`);
        return result.length;
    } catch (error) {
        console.error('[Storage] Error deleting old messages:', error);
        throw error;
    }
}
