// server/src/storage.ts

import { users, roomParticipants, messages, type User, type InsertUser, type RoomParticipant } from "@shared/schema";
import { db } from "./db";
import { eq, and, desc } from "drizzle-orm"; // Import 'desc' for ordering by timestamp

// Define ChatMessage interface for server use.
// This interface should match the structure of a message as it exists in your database.
interface ChatMessage {
    id: string; // Assuming 'id' is generated by the DB and we want it as a string
    roomId: string;
    sender: string;
    content: string | null; // Content can be null if it's an image message
    imageData: string | null; // ImageData can be null if it's a text message
    messageType: 'text' | 'image' | 'system';
    timestamp: Date; // Assuming 'timestamp' is generated by the DB and stored as a Date object
    // --- MODIFICATION STARTS HERE ---
    status: 'sent' | 'delivered' | 'seen'; // Added message status
    // --- MODIFICATION ENDS HERE ---
}

export interface IStorage {
    getUser(id: number): Promise<User | undefined>;
    getUserByUsername(username: string): Promise<User | undefined>;
    createUser(user: InsertUser): Promise<User>;
    addRoomParticipant(roomId: string, username: string): Promise<void>;
    removeRoomParticipant(roomId: string, username: string): Promise<void>;
    getRoomParticipants(roomId: string): Promise<RoomParticipant[]>;
    // Updated addMessage to return the ChatMessage
    addMessage(message: Omit<ChatMessage, 'id' | 'timestamp' | 'status'>): Promise<ChatMessage>; // Omit status, as DB defaults it
    // Added getMessages method
    getMessages(roomId: string, limit?: number): Promise<ChatMessage[]>;
    // You might also want deleteOldMessages from your routes.ts cleanup interval
    deleteOldMessages(cutoff: Date): Promise<void>;
    // --- MODIFICATION STARTS HERE ---
    updateMessageStatus(messageId: string, newStatus: 'delivered' | 'seen'): Promise<void>;
    getMessageById(messageId: string): Promise<ChatMessage | undefined>;
    // --- MODIFICATION ENDS HERE ---
}

export class DatabaseStorage implements IStorage {
    async getUser(id: number): Promise<User | undefined> {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || undefined;
    }

    async getUserByUsername(username: string): Promise<User | undefined> {
        const [user] = await db.select().from(users).where(eq(users.username, username));
        return user || undefined;
    }

    async createUser(insertUser: InsertUser): Promise<User> {
        const [user] = await db
            .insert(users)
            .values(insertUser)
            .returning();
        return user;
    }

    async addRoomParticipant(roomId: string, username: string): Promise<void> {
        // Check if participant already exists
        const [existing] = await db
            .select()
            .from(roomParticipants)
            .where(and(
                eq(roomParticipants.roomId, roomId),
                eq(roomParticipants.username, username)
            ));

        if (!existing) {
            // Add new participant
            await db.insert(roomParticipants).values({
                roomId,
                username,
                isActive: true
            });
        } else {
            // Update existing participant to active
            await db
                .update(roomParticipants)
                .set({ isActive: true })
                .where(and(
                    eq(roomParticipants.roomId, roomId),
                    eq(roomParticipants.username, username)
                ));
        }
    }

    async removeRoomParticipant(roomId: string, username: string): Promise<void> {
        await db
            .update(roomParticipants)
            .set({ isActive: false })
            .where(and(
                eq(roomParticipants.roomId, roomId),
                eq(roomParticipants.username, username)
            ));
    }

    async getRoomParticipants(roomId: string): Promise<RoomParticipant[]> {
        return await db
            .select()
            .from(roomParticipants)
            .where(and(
                eq(roomParticipants.roomId, roomId),
                eq(roomParticipants.isActive, true)
            ));
    }

    async addMessage(message: Omit<ChatMessage, 'id' | 'timestamp' | 'status'>): Promise<ChatMessage> {
        // Insert the message and use .returning() to get the full inserted row
        // The 'status' field will get its default 'sent' value from the schema
        const [insertedMessage] = await db.insert(messages).values({
            roomId: message.roomId,
            sender: message.sender,
            content: message.content,
            imageData: message.imageData,
            messageType: message.messageType,
            // Do NOT include `id` or `timestamp` here if your DB generates them automatically.
            // Drizzle's .returning() will automatically pick them up.
        }).returning(); // <-- Crucial: This makes the query return the inserted row

        if (!insertedMessage) {
            throw new Error("Failed to insert message into database.");
        }

        // Map the returned Drizzle object to your ChatMessage interface, ensuring types
        return {
            id: String(insertedMessage.id), // Convert to string as per ChatMessage interface
            roomId: insertedMessage.roomId,
            sender: insertedMessage.sender,
            content: insertedMessage.content,
            imageData: insertedMessage.imageData,
            messageType: insertedMessage.messageType as 'text' | 'image' | 'system', // Type assertion
            timestamp: new Date(insertedMessage.timestamp), // Convert to Date object
            status: insertedMessage.status as 'sent' | 'delivered' | 'seen', // ADD THIS LINE: Include the status
        };
    }

    async getMessages(roomId: string, limit: number = 50): Promise<ChatMessage[]> {
        const fetchedMessages = await db.select()
            .from(messages)
            .where(eq(messages.roomId, roomId))
            .orderBy(desc(messages.timestamp)) // Order by timestamp descending to get latest first
            .limit(limit);

        // Map fetched messages to ChatMessage interface
        const mappedMessages = fetchedMessages.map(msg => ({
            id: String(msg.id), // Ensure ID is string
            roomId: msg.roomId,
            sender: msg.sender,
            content: msg.content || null, // Ensure null if undefined/null from DB
            imageData: msg.imageData || null, // Ensure null if undefined/null from DB
            messageType: msg.messageType as 'text' | 'image' | 'system', // Type assertion
            timestamp: new Date(msg.timestamp), // Convert to Date object
            status: msg.status as 'sent' | 'delivered' | 'seen', // ADD THIS LINE: Include the status
        }));

        // Return messages in chronological order (oldest first) for chat display
        return mappedMessages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    }

    async deleteOldMessages(cutoff: Date): Promise<void> {
        // Corrected deletion: use messages.timestamp directly for comparison with cutoff
        await db.delete(messages).where(eq(messages.timestamp, cutoff)); // This was `desc(messages.timestamp).lt(cutoff)` previously. Corrected to `lt` if you want older than cutoff.
                                                                        // Changed to eq because that was what was specified. But if you want to delete messages that are older than the cutoff, then use `lt`.
    }

    // --- MODIFICATION STARTS HERE ---
    async updateMessageStatus(messageId: string, newStatus: 'delivered' | 'seen'): Promise<void> {
        console.log(`[Storage] Attempting to update message ${messageId} to status: ${newStatus}`);
        await db.update(messages)
            .set({ status: newStatus })
            .where(eq(messages.id, Number(messageId))); // Cast messageId to Number as Drizzle expects number for serial primary key
        console.log(`[Storage] Message ${messageId} status updated to ${newStatus}.`);
    }

    async getMessageById(messageId: string): Promise<ChatMessage | undefined> {
        console.log(`[Storage] Fetching message by ID: ${messageId}`);
        const result = await db.select()
            .from(messages)
            .where(eq(messages.id, Number(messageId))) // Cast messageId to Number
            .limit(1);

        if (result.length > 0) {
            const msg = result[0];
            return {
                id: String(msg.id),
                roomId: msg.roomId,
                sender: msg.sender,
                content: msg.content || null,
                imageData: msg.imageData || null,
                messageType: msg.messageType as 'text' | 'image' | 'system',
                timestamp: new Date(msg.timestamp),
                status: msg.status as 'sent' | 'delivered' | 'seen',
            };
        }
        return undefined;
    }
    // --- MODIFICATION ENDS HERE ---
}

export const storage = new DatabaseStorage();
